{"version":3,"sources":["webpack:///webpack/bootstrap 7006d66b86f3a6ff3c11","webpack:///(webpack)/buildin/global.js","webpack:///./custom-component.js","webpack:////Users/janrembold/GitHub/webcomponent-examples/node_modules/slim-js/Slim.js","webpack:////Users/janrembold/GitHub/webcomponent-examples/node_modules/node-libs-browser/node_modules/timers-browserify/main.js","webpack:////Users/janrembold/GitHub/webcomponent-examples/node_modules/setimmediate/setImmediate.js","webpack:////Users/janrembold/GitHub/webcomponent-examples/node_modules/process/browser.js","webpack:////Users/janrembold/GitHub/webcomponent-examples/node_modules/slim-js/Decorators.js"],"names":["CustomComponent"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;ACpBA;;AACA;;;;;;;;;;AAEA,CAAC,YAAY;AACT;;AADS;;AAAA,MAKHA,eALG,WAGR,qBAAI,kBAAJ,CAHQ,UAIR,0BAAS,yCAAT,CAJQ;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAOZ,CAPD,I;;;;;;;oDCHA;;AAEA,qDAAqD,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,wCAAwC,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE;;AAExe,kCAAkC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,yCAAyC,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa,EAAE,2BAA2B,0BAA0B,YAAY,EAAE,2CAA2C,8BAA8B,EAAE,OAAO,6EAA6E,EAAE,GAAG,EAAE;;AAErpB,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;;AAEA;AACA,wFAAwF,gEAAgE;AACxJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,2FAA2F,aAAa;AACxG;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC,EAAE;AAClC;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,mEAAmE;AACvI;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gGAAgG,mEAAmE;AACnK;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,uDAAuD,eAAe;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA,0EAA0E,eAAe;AACzF;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,0EAA0E,eAAe;AACzF;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG,gBAAgB;AACnB;AACA;AACA;AACA,GAAG,gBAAgB;;AAEnB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,4CAA4C,EAAE,KAAK,EAAE,MAAM,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,eAAe,EAAE,EAAE,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,mBAAmB,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;AC/nCD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3DA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;ACzLD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA,uEAAuE,cAAc,EAAE;AACvF;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E","file":"custom-component.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7006d66b86f3a6ff3c11","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0 1","import {Slim} from 'slim-js/Slim';\nimport {tag, template} from 'slim-js/Decorators';\n\n(function () {\n    'use strict';\n\n    @tag('custom-component')\n    @template('<div>Hello, i am a custom element</div>')\n    class CustomComponent extends Slim {\n    }\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./custom-component.js","'use strict';\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _CustomElement() {\n  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);\n}\n\n;\nObject.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(_CustomElement, HTMLElement);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n(function (window, document, HTMLElement) {\n\n  var __flags = {\n    isWCSupported: 'customElements' in window && 'import' in document.createElement('link') && 'content' in document.createElement('template'),\n    isIE11: !!window['MSInputMethodContext'] && !!document['documentMode'],\n    isChrome: undefined,\n    isEdge: undefined\n  };\n\n  try {\n    __flags.isChrome = /Chrome/.test(navigator.userAgent);\n    __flags.isEdge = /Edge/.test(navigator.userAgent);\n\n    if (__flags.isIE11 || __flags.isEdge) {\n      __flags.isChrome = false;\n      Object.defineProperty(Node.prototype, 'children', function () {\n        return this.childNodes;\n      });\n    }\n  } catch (err) {}\n\n  var _$2 = '_slim_internals_'; //Symbol('Slim')\n\n  var Internals = function Internals() {\n    _classCallCheck(this, Internals);\n\n    this.hasCustomTemplate = undefined;\n    this.boundParent = null;\n    this.repeater = {};\n    this.bindings = {};\n    this.reversed = {};\n    this.inbounds = {};\n    this.eventHandlers = {};\n    this.internetExploderClone = null;\n    this.rootElement = null;\n    this.createdCallbackInvoked = false;\n    this.sourceText = null;\n    this.excluded = false;\n    this.autoBoundAttributes = [];\n  };\n\n  var Slim = function (_CustomElement2) {\n    _inherits(Slim, _CustomElement2);\n\n    _createClass(Slim, null, [{\n      key: 'dashToCamel',\n      value: function dashToCamel(dash) {\n        return dash.indexOf('-') < 0 ? dash : dash.replace(/-[a-z]/g, function (m) {\n          return m[1].toUpperCase();\n        });\n      }\n    }, {\n      key: 'camelToDash',\n      value: function camelToDash(camel) {\n        return camel.replace(/([A-Z])/g, '-$1').toLowerCase();\n      }\n    }, {\n      key: 'lookup',\n      value: function lookup(target, expression, maybeRepeated) {\n        var chain = expression.split('.');\n        var o = void 0;\n        if (maybeRepeated && maybeRepeated[_$2].repeater[chain[0]]) {\n          o = maybeRepeated[_$2].repeater;\n        } else {\n          o = target;\n        }\n        var i = 0;\n        while (o && i < chain.length) {\n          o = o[chain[i++]];\n        }\n        return o;\n      }\n\n      // noinspection JSUnresolvedVariable\n\n    }, {\n      key: '_$',\n      value: function _$(target) {\n        target[_$2] = target[_$2] || new Internals();\n        return target[_$2];\n      }\n    }, {\n      key: 'polyFill',\n      value: function polyFill(url) {\n        if (!__flags.isWCSupported) {\n          var existingScript = document.querySelector('script[data-is-slim-polyfill=\"true\"]');\n          if (!existingScript) {\n            var script = document.createElement('script');\n            script.setAttribute('data-is-slim-polyfill', 'true');\n            script.src = url;\n            document.head.appendChild(script);\n          }\n        }\n      }\n    }, {\n      key: 'tag',\n      value: function tag(tagName, tplOrClazz, clazz) {\n        if (this.tagToClassDict.has(tagName)) {\n          throw new Error('Unable to define tag: ' + tagName + ' already defined');\n        }\n        if (clazz === undefined) {\n          clazz = tplOrClazz;\n        } else {\n          Slim.tagToTemplateDict.set(tagName, tplOrClazz);\n        }\n        this.tagToClassDict.set(tagName, clazz);\n        this.classToTagDict.set(clazz, tagName);\n        customElements.define(tagName, clazz);\n      }\n    }, {\n      key: 'tagOf',\n      value: function tagOf(clazz) {\n        return this.classToTagDict.get(clazz);\n      }\n    }, {\n      key: 'classOf',\n      value: function classOf(tag) {\n        return this.tagToClassDict.get(tag);\n      }\n    }, {\n      key: 'createUniqueIndex',\n      value: function createUniqueIndex() {\n        this[_$2].uniqueCounter++;\n        return this[_$2].uniqueCounter.toString(16);\n      }\n    }, {\n      key: 'plugin',\n      value: function plugin(phase, _plugin) {\n        if (!this.plugins[phase]) {\n          throw new Error('Cannot attach plugin: ' + phase + ' is not a supported phase');\n        }\n        this.plugins[phase].push(_plugin);\n      }\n    }, {\n      key: 'checkCreationBlocking',\n      value: function checkCreationBlocking(element) {\n        if (element.attributes) {\n          for (var i = 0, n = element.attributes.length; i < n; i++) {\n            var attribute = element.attributes[i];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = Slim[_$2].customDirectives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _ref = _step.value;\n\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                var test = _ref2[0];\n                var directive = _ref2[1];\n\n                var value = directive.isBlocking && test(attribute);\n                if (value) {\n                  return true;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n        }\n        return false;\n      }\n    }, {\n      key: 'customDirective',\n      value: function customDirective(testFn, fn, isBlocking) {\n        if (this[_$2].customDirectives.has(testFn)) {\n          throw new Error('Cannot register custom directive: ' + testFn + ' already registered');\n        }\n        fn.isBlocking = isBlocking;\n        this[_$2].customDirectives.set(testFn, fn);\n      }\n    }, {\n      key: 'executePlugins',\n      value: function executePlugins(phase, target) {\n        this.plugins[phase].forEach(function (fn) {\n          fn(target);\n        });\n      }\n    }, {\n      key: 'qSelectAll',\n      value: function qSelectAll(target, selector) {\n        return [].concat(_toConsumableArray(target.querySelectorAll(selector)));\n      }\n    }, {\n      key: 'unbind',\n      value: function unbind(source, target) {\n        var bindings = source[_$2].bindings;\n        Object.keys(bindings).forEach(function (key) {\n          var chain = bindings[key].chain.filter(function (binding) {\n            if (binding.target === target) {\n              binding.destroy();\n              return false;\n            }\n            return true;\n          });\n          bindings[key].chain = chain;\n        });\n      }\n    }, {\n      key: 'root',\n      value: function root(target) {\n        return target.__isSlim && target.useShadow ? target[_$2].rootElement || target : target;\n      }\n    }, {\n      key: 'selectRecursive',\n      value: function selectRecursive(target, force) {\n        var collection = [];\n        var search = function search(node, force) {\n          collection.push(node);\n          var allow = !node.__isSlim || node.__isSlim && !node.template || node.__isSlim && node === target || force;\n          if (allow) {\n            var children = [].concat(_toConsumableArray(Slim.root(node).children));\n            children.forEach(function (childNode) {\n              search(childNode, force);\n            });\n          }\n        };\n        search(target, force);\n        return collection;\n      }\n    }, {\n      key: 'removeChild',\n      value: function removeChild(target) {\n        if (typeof target.remove === 'function') {\n          target.remove();\n        }\n        if (target.parentNode) {\n          target.parentNode.removeChild(target);\n        }\n        if (this._$(target).internetExploderClone) {\n          this.removeChild(this._$(target).internetExploderClone);\n        }\n      }\n    }, {\n      key: 'moveChildren',\n      value: function moveChildren(source, target) {\n        while (source.firstChild) {\n          target.appendChild(source.firstChild);\n        }\n      }\n    }, {\n      key: 'wrapGetterSetter',\n      value: function wrapGetterSetter(element, expression) {\n        var pName = expression.split('.')[0];\n        var oSetter = element.__lookupSetter__(pName);\n        if (oSetter && oSetter[_$2]) return pName;\n        if (typeof oSetter === 'undefined') {\n          oSetter = function oSetter() {};\n        }\n\n        var srcValue = element[pName];\n        this._$(element).bindings[pName] = element[_$2].bindings[pName] || {\n          chain: [],\n          value: srcValue\n        };\n        element[_$2].bindings[pName].value = srcValue;\n        var newSetter = function newSetter(v) {\n          oSetter.call(element, v);\n          this[_$2].bindings[pName].value = v;\n          this._executeBindings(pName);\n        };\n        newSetter[_$2] = true;\n        element.__defineGetter__(pName, function () {\n          return element[_$2].bindings[pName].value;\n        });\n        element.__defineSetter__(pName, newSetter);\n        return pName;\n      }\n    }, {\n      key: 'bindOwn',\n      value: function bindOwn(target, expression, executor) {\n        return Slim.bind(target, target, expression, executor);\n      }\n    }, {\n      key: 'bind',\n      value: function bind(source, target, expression, executor) {\n        Slim._$(source);\n        Slim._$(target);\n        if (target[_$2].excluded) return;\n        executor.source = source;\n        executor.target = target;\n        var pName = this.wrapGetterSetter(source, expression);\n        if (!source[_$2].reversed[pName]) {\n          source[_$2].bindings[pName].chain.push(executor);\n        }\n        target[_$2].inbounds[pName] = target[_$2].inbounds[pName] || [];\n        target[_$2].inbounds[pName].push(executor);\n        return executor;\n      }\n    }, {\n      key: 'update',\n      value: function update(target) {\n        var children = Slim.selectRecursive(target);\n\n        for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          props[_key - 1] = arguments[_key];\n        }\n\n        if (props.length === 0) {\n          return children.forEach(function (child) {\n            Slim.commit(child);\n          });\n        }\n        props.forEach(function (prop) {\n          children.forEach(function (child) {\n            Slim.commit(child, prop);\n          });\n        });\n      }\n    }, {\n      key: 'commit',\n      value: function commit(target, prop) {\n        var keys = void 0;\n        var $ = target[_$2];\n        var chain = [];\n        if (prop) {\n          if ($.inbounds[prop]) {\n            chain = chain.concat($.inbounds[prop] || []);\n          }\n          if ($.bindings[prop]) {\n            chain = chain.concat($.bindings[prop].chain);\n          }\n        } else {\n          Object.keys(target[_$2].inbounds).forEach(function (prop) {\n            if ($.inbounds[prop]) {\n              chain = chain.concat($.inbounds[prop] || []);\n            }\n            if ($.bindings[prop]) {\n              chain = chain.concat($.bindings[prop].chain);\n            }\n          });\n        }\n        chain.forEach(function (x) {\n          return x();\n        });\n      }\n\n      /*\r\n        Class instance\r\n        */\n\n    }, {\n      key: 'rxInject',\n      get: function get() {\n        return (/\\{(.+[^(\\((.+)\\))])\\}/\n        );\n      }\n    }, {\n      key: 'rxProp',\n      get: function get() {\n        return (/(.+[^(\\((.+)\\))])/\n        );\n      }\n    }, {\n      key: 'rxMethod',\n      get: function get() {\n        return (/(.+)(\\((.+)\\)){1}/\n        );\n      }\n    }]);\n\n    function Slim() {\n      _classCallCheck(this, Slim);\n\n      var _this = _possibleConstructorReturn(this, (Slim.__proto__ || Object.getPrototypeOf(Slim)).call(this));\n\n      _this.__isSlim = true;\n      Slim.debug('ctor', _this.localName);\n      if (Slim.checkCreationBlocking(_this)) {\n        return _possibleConstructorReturn(_this);\n      }\n      _this.createdCallback();\n      return _this;\n    }\n\n    // Native DOM Api V1\n\n    _createClass(Slim, [{\n      key: 'createdCallback',\n      value: function createdCallback() {\n        if (this[_$2] && this[_$2].createdCallbackInvoked) return;\n        this._initialize();\n        this[_$2].createdCallbackInvoked = true;\n        this.onBeforeCreated();\n        Slim.executePlugins('create', this);\n        this.render();\n        this.onCreated();\n      }\n\n      // Native DOM Api V2\n\n    }, {\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        this.onAdded();\n        Slim.executePlugins('added', this);\n      }\n    }, {\n      key: 'disconnectedCallback',\n      value: function disconnectedCallback() {\n        this.onRemoved();\n        Slim.executePlugins('removed', this);\n      }\n    }, {\n      key: 'attributeChangedCallback',\n      value: function attributeChangedCallback(attr, oldValue, newValue) {\n        if (newValue !== oldValue && this[_$2].autoBoundAttributes[attr]) {\n          var prop = Slim.dashToCamel(attr);\n          this[prop] = newValue;\n        }\n      }\n\n      // Slim internal API\n\n    }, {\n      key: '_executeBindings',\n      value: function _executeBindings(prop) {\n        var _this2 = this;\n\n        Slim.debug('_executeBindings', this.localName);\n        var all = this[_$2].bindings;\n        if (prop) {\n          all = _defineProperty({}, prop, true);\n        }\n        Object.keys(all).forEach(function (pName) {\n          var o = _this2[_$2].bindings[pName];\n          o && o.chain.forEach(function (binding) {\n            return binding();\n          });\n        });\n      }\n    }, {\n      key: '_bindChildren',\n      value: function _bindChildren(children) {\n        Slim.debug('_bindChildren', this.localName);\n        if (!children) {\n          children = Slim.qSelectAll(this, '*');\n        }\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var child = _step2.value;\n\n            Slim._$(child);\n            if (child[_$2].boundParent === this) continue;\n            child[_$2].boundParent = child[_$2].boundParent || this;\n\n            // todo: child.localName === 'style' && this.useShadow -> processStyleNodeInShadowMode\n\n            if (child.attributes.length) {\n              var i = 0;\n              var n = child.attributes.length;\n              while (i < n) {\n                var source = this;\n                var attribute = child.attributes.item(i);\n                if (!child[_$2].excluded) {\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n\n                  try {\n                    for (var _iterator3 = Slim[_$2].customDirectives[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      var _ref3 = _step3.value;\n\n                      var _ref4 = _slicedToArray(_ref3, 2);\n\n                      var check = _ref4[0];\n                      var directive = _ref4[1];\n\n                      var match = check(attribute);\n                      if (match) {\n                        directive(source, child, attribute, match);\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                }\n                i++;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }, {\n      key: '_resetBindings',\n      value: function _resetBindings() {\n        Slim.debug('_resetBindings', this.localName);\n        this[_$2].bindings = {};\n      }\n    }, {\n      key: '_render',\n      value: function _render(customTemplate) {\n        var _this3 = this;\n\n        Slim.debug('_render', this.localName);\n        Slim.executePlugins('beforeRender', this);\n        this[_$2].hasCustomTemplate = customTemplate;\n        this._resetBindings();\n        this[_$2].rootElement.innerHTML = '';[].concat(_toConsumableArray(this.childNodes)).forEach(function (childNode) {\n          if (childNode.localName === 'style') {\n            _this3[_$2].externalStyle = childNode;\n            childNode.remove();\n          }\n        });\n        var template = this[_$2].hasCustomTemplate || this.template;\n        if (template && typeof template === 'string') {\n          var frag = document.createElement('slim-root-fragment');\n          frag.innerHTML = template || '';\n          var scopedChildren = Slim.qSelectAll(frag, '*');\n          if (this[_$2].externalStyle) {\n            this._bindChildren([this[_$2].externalStyle]);\n          }\n          this._bindChildren(scopedChildren);\n          Slim.asap(function () {\n            Slim.moveChildren(frag, _this3[_$2].rootElement || _this3);\n            _this3[_$2].externalStyle && _this3[_$2].rootElement.appendChild(_this3[_$2].externalStyle);\n            _this3._executeBindings();\n            _this3.onRender();\n            Slim.executePlugins('afterRender', _this3);\n            _this3.dispatchEvent(new Event('afterRender'));\n          });\n        }\n      }\n    }, {\n      key: '_initialize',\n      value: function _initialize() {\n        var _this4 = this;\n\n        Slim.debug('_initialize', this.localName);\n        Slim._$(this);\n        this[_$2].uniqueIndex = Slim.createUniqueIndex();\n        if (this.useShadow) {\n          if (typeof HTMLElement.prototype.attachShadow === 'undefined') {\n            this[_$2].rootElement = this.createShadowRoot();\n          } else {\n            this[_$2].rootElement = this.attachShadow({ mode: 'open' });\n          }\n        } else {\n          this[_$2].rootElement = this;\n        }\n        // this.setAttribute('slim-uq', this[_$].uniqueIndex)\n        var observedAttributes = this.constructor.observedAttributes;\n        if (observedAttributes) {\n          observedAttributes.forEach(function (attr) {\n            var pName = Slim.dashToCamel(attr);\n            _this4[pName] = _this4.getAttribute(attr);\n          });\n        }\n      }\n\n      // Slim public / protected API\n\n    }, {\n      key: 'commit',\n      value: function commit() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        Slim.commit.apply(Slim, [this].concat(args));\n      }\n    }, {\n      key: 'update',\n      value: function update() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        Slim.update.apply(Slim, [this].concat(args));\n      }\n    }, {\n      key: 'render',\n      value: function render(tpl) {\n        this._render(tpl);\n      }\n    }, {\n      key: 'onRender',\n      value: function onRender() {}\n    }, {\n      key: 'onBeforeCreated',\n      value: function onBeforeCreated() {}\n    }, {\n      key: 'onCreated',\n      value: function onCreated() {}\n    }, {\n      key: 'onAdded',\n      value: function onAdded() {}\n    }, {\n      key: 'onRemoved',\n      value: function onRemoved() {}\n    }, {\n      key: 'find',\n      value: function find(selector) {\n        return this[_$2].rootElement.querySelector(selector);\n      }\n    }, {\n      key: 'findAll',\n      value: function findAll(selector) {\n        return Slim.qSelectAll(this[_$2].rootElement, selector);\n      }\n    }, {\n      key: 'callAttribute',\n      value: function callAttribute(attr, data) {\n        var fnName = this.getAttribute(attr);\n        if (fnName) {\n          return this[_$2].boundParent[fnName](data);\n        }\n      }\n    }, {\n      key: '_isInContext',\n      get: function get() {\n        var node = this;\n        while (node) {\n          node = node.parentNode;\n          if (!node) {\n            return false;\n          }\n          if (node instanceof Document) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }, {\n      key: 'useShadow',\n      get: function get() {\n        return false;\n      }\n    }, {\n      key: 'template',\n      get: function get() {\n        return Slim.tagToTemplateDict.get(Slim.tagOf(this.constructor));\n      }\n    }]);\n\n    return Slim;\n  }(_CustomElement);\n\n  Slim.uniqueIndex = 0;\n  Slim.tagToClassDict = new Map();\n  Slim.classToTagDict = new Map();\n  Slim.tagToTemplateDict = new Map();\n  Slim.plugins = {\n    'create': [],\n    'added': [],\n    'beforeRender': [],\n    'afterRender': [],\n    'removed': []\n  };\n\n  Slim.debug = function () {};\n\n  Slim.asap = window && window.requestAnimationFrame ? function (cb) {\n    return window.requestAnimationFrame(cb);\n  } : typeof setImmediate !== 'undefined' ? setImmediate : function (cb) {\n    return setTimeout(cb, 0);\n  };\n\n  Slim[_$2] = {\n    customDirectives: new Map(),\n    uniqueCounter: 0,\n    supportedNativeEvents: ['click', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'wheel', 'mouseleave', 'select', 'pointerlockchange', 'pointerlockerror', 'focus', 'blur', 'input', 'error', 'invalid', 'animationstart', 'animationend', 'animationiteration', 'reset', 'submit', 'resize', 'scroll', 'keydown', 'keypress', 'keyup', 'change']\n  };\n\n  Slim.customDirective(function (attr) {\n    return attr.nodeName === 's:switch';\n  }, function (source, target, attribute) {\n    var expression = attribute.value;\n    var oldValue = void 0;\n    var anchor = document.createComment('switch:' + expression);\n    target.appendChild(anchor);\n    var children = [].concat(_toConsumableArray(target.children));\n    var defaultChildren = children.filter(function (child) {\n      return child.hasAttribute('s:default');\n    });\n    var fn = function fn() {\n      var value = Slim.lookup(source, expression, target);\n      if (String(value) === oldValue) return;\n      var useDefault = true;\n      children.forEach(function (child) {\n        if (child.getAttribute('s:case') === String(value)) {\n          if (child.__isSlim) {\n            child.createdCallback();\n          }\n          anchor.parentNode.insertBefore(child, anchor);\n          useDefault = false;\n        } else {\n          Slim.removeChild(child);\n        }\n      });\n      if (useDefault) {\n        defaultChildren.forEach(function (child) {\n          if (child.__isSlim) {\n            child.createdCallback();\n          }\n          anchor.parentNode.insertBefore(child, anchor);\n        });\n      } else {\n        defaultChildren.forEach(function (child) {\n          Slim.removeChild(child);\n        });\n      }\n      oldValue = String(value);\n    };\n    Slim.bind(source, target, expression, fn);\n  });\n\n  Slim.customDirective(function (attr) {\n    return (/^s:case$/.exec(attr.nodeName)\n    );\n  }, function () {}, true);\n  Slim.customDirective(function (attr) {\n    return (/^s:default$/.exec(attr.nodeName)\n    );\n  }, function () {}, true);\n\n  // supported events (i.e. click, mouseover, change...)\n  Slim.customDirective(function (attr) {\n    return Slim[_$2].supportedNativeEvents.indexOf(attr.nodeName) >= 0;\n  }, function (source, target, attribute) {\n    var eventName = attribute.nodeName;\n    var delegate = attribute.value;\n    Slim._$(target).eventHandlers = target[_$2].eventHandlers || {};\n    var allHandlers = target[_$2].eventHandlers;\n    allHandlers[eventName] = allHandlers[eventName] || [];\n    var handler = function handler(e) {\n      try {\n        source[delegate].call(source, e);\n      } catch (err) {\n        err.message = 'Could not respond to event \"' + eventName + '\" on ' + target.localName + ' -> \"' + delegate + '\" on ' + source.localName + ' ... ' + err.message;\n        console.warn(err);\n      }\n    };\n    allHandlers[eventName].push(handler);\n    target.addEventListener(eventName, handler);\n    handler = null;\n  });\n\n  Slim.customDirective(function (attr) {\n    return attr.nodeName === 's:if';\n  }, function (source, target, attribute) {\n    var expression = attribute.value;\n    var path = expression;\n    var isNegative = false;\n    if (path.charAt(0) === '!') {\n      path = path.slice(1);\n      isNegative = true;\n    }\n    var oldValue = void 0;\n    var anchor = document.createComment('if:' + expression);\n    target.parentNode.insertBefore(anchor, target);\n    var fn = function fn() {\n      var value = !!Slim.lookup(source, path, target);\n      if (isNegative) {\n        value = !value;\n      }\n      if (value === oldValue) return;\n      if (value) {\n        if (target.__isSlim) {\n          target.createdCallback();\n        }\n        anchor.parentNode.insertBefore(target, anchor.nextSibling);\n      } else {\n        Slim.removeChild(target);\n      }\n      oldValue = value;\n    };\n    Slim.bind(source, target, path, fn);\n  }, true);\n\n  // bind (text nodes)\n  Slim.customDirective(function (attr) {\n    return attr.nodeName === 'bind';\n  }, function (source, target) {\n    Slim._$(target);\n    target[_$2].sourceText = target.innerText;\n    var updatedText = '';\n    var matches = target.innerText.match(/\\{\\{([^\\}\\}]+)+\\}\\}/g);\n    var aggProps = {};\n    var textBinds = {};\n    if (matches) {\n      matches.forEach(function (expression) {\n        var oldValue = void 0;\n        var rxM = /\\{\\{(.+)(\\((.+)\\)){1}\\}\\}/.exec(expression);\n        if (rxM) {\n          var fnName = rxM[1];\n          var pNames = rxM[3].split(' ').join('').split(',');\n          pNames.map(function (path) {\n            return path.split('.')[0];\n          }).forEach(function (p) {\n            return aggProps[p] = true;\n          });\n          textBinds[expression] = function (target) {\n            var args = pNames.map(function (path) {\n              return Slim.lookup(source, path, target);\n            });\n            var fn = source[fnName];\n            var value = fn ? fn.apply(source, args) : undefined;\n            if (oldValue === value) return;\n            updatedText = updatedText.split(expression).join(value || '');\n          };\n          return;\n        }\n        var rxP = /\\{\\{(.+[^(\\((.+)\\))])\\}\\}/.exec(expression);\n        if (rxP) {\n          var path = rxP[1];\n          aggProps[path] = true;\n          textBinds[expression] = function (target) {\n            var value = Slim.lookup(source, path, target);\n            if (oldValue === value) return;\n            updatedText = updatedText.split(expression).join(value || '');\n          };\n        }\n      });\n      var chainExecutor = function chainExecutor() {\n        updatedText = target[_$2].sourceText;\n        Object.keys(textBinds).forEach(function (expression) {\n          textBinds[expression](target);\n        });\n        target.innerText = updatedText;\n      };\n      Object.keys(aggProps).forEach(function (prop) {\n        Slim.bind(source, target, prop, chainExecutor);\n      });\n    }\n  });\n\n  Slim.customDirective(function (attr) {\n    return attr.nodeName === 's:id';\n  }, function (source, target, attribute) {\n    Slim._$(target).boundParent[attribute.value] = target;\n  });\n\n  // bind:property\n  Slim.customDirective(function (attr) {\n    return (/^(bind):(\\S+)/.exec(attr.nodeName)\n    );\n  }, function (source, target, attribute, match) {\n    var tAttr = match[2];\n    var tProp = Slim.dashToCamel(tAttr);\n    var expression = attribute.value;\n    var oldValue = void 0;\n    var rxM = Slim.rxMethod.exec(expression);\n    if (rxM) {\n      var pNames = rxM[3].split(' ').join('').split(',');\n      pNames.forEach(function (pName) {\n        Slim.bind(source, target, pName, function () {\n          var fn = Slim.lookup(source, rxM[1], target);\n          var args = pNames.map(function (prop) {\n            return Slim.lookup(source, prop, target);\n          });\n          var value = fn.apply(source, args);\n          if (oldValue === value) return;\n          target[tProp] = value;\n          target.setAttribute(tAttr, value);\n        });\n      });\n      return;\n    }\n    var rxP = Slim.rxProp.exec(expression);\n    if (rxP) {\n      var prop = rxP[1];\n      Slim.bind(source, target, prop, function () {\n        var value = Slim.lookup(source, expression, target);\n        if (oldValue === value) return;\n        target.setAttribute(tAttr, value);\n        target[tProp] = value;\n      });\n    }\n  });\n\n  __flags.isChrome && Slim.customDirective(function (attr) {\n    return attr.nodeName === 's:repeat';\n  }, function (source, templateNode, attribute) {\n    var path = attribute.value;\n    var tProp = 'data';\n    if (path.indexOf(' as')) {\n      tProp = path.split(' as ')[1] || tProp;\n      path = path.split(' as ')[0];\n    }\n\n    var clones = [];\n    var hook = document.createComment(templateNode.localName + ' s:repeat=\"' + attribute.value + '\"');\n    var templateHTML = void 0;\n    Slim._$(hook);\n    Slim.selectRecursive(templateNode, true).forEach(function (e) {\n      return Slim._$(e).excluded = true;\n    });\n    templateNode.parentElement.insertBefore(hook, templateNode);\n    templateNode.remove();\n    Slim.unbind(source, templateNode);\n    Slim.asap(function () {\n      templateNode.setAttribute('s:iterate', '');\n      templateNode.removeAttribute('s:repeat');\n      templateHTML = templateNode.outerHTML;\n      templateNode.innerHTML = '';\n    });\n    var oldDataSource = [];\n    Slim.bind(source, hook, path, function () {\n      var dataSource = Slim.lookup(source, path) || [];\n      var offset = 0;\n      var restOfData = [];\n      // get the diff\n      var diff = Array(dataSource.length);\n      dataSource.forEach(function (d, i) {\n        if (oldDataSource[i] !== d) {\n          diff[i] = true;\n        }\n      });\n      oldDataSource = dataSource.concat();\n      var indices = Object.keys(diff);\n      if (dataSource.length < clones.length) {\n        var disposables = clones.slice(dataSource.length);\n        clones = clones.slice(0, dataSource.length);\n        disposables.forEach(function (clone) {\n          return clone.remove();\n        });\n        // unbind disposables?\n        indices.forEach(function (index) {\n          var clone = clones[index];[clone].concat(Slim.qSelectAll(clone, '*')).forEach(function (t) {\n            t[_$2].repeater[tProp] = dataSource[index];\n            Slim.commit(t, tProp);\n          });\n        });\n      } else {\n        // recycle\n        clones.length && indices.forEach(function (index) {\n          var clone = clones[index];\n          if (!clone) return;\n          [clone].concat(Slim.qSelectAll(clone, '*')).forEach(function (t) {\n            t[_$2].repeater[tProp] = dataSource[index];\n            Slim.commit(t, tProp);\n          });\n        });\n        restOfData = dataSource.slice(clones.length);\n        offset = clones.length;\n      }\n      if (!restOfData.length) return;\n      // new clones\n      var range = document.createRange();\n      range.setStartBefore(hook);\n      var html = Array(restOfData.length).fill(templateHTML).join('');\n      var frag = range.createContextualFragment(html);\n      var all = [];\n      var i = 0;\n      while (i < frag.children.length) {\n        var e = frag.children.item(i);\n        clones.push(e);\n        all.push(e);\n        Slim._$(e).repeater[tProp] = dataSource[i + offset];\n        var subTree = Slim.qSelectAll(e, '*');\n        subTree.forEach(function (t) {\n          all.push(t);\n          Slim._$(t).repeater[tProp] = dataSource[i + offset];\n          Slim.commit(t, tProp);\n        });\n        i++;\n      }\n      source._bindChildren(all);\n      all.forEach(function (t) {\n        if (t.__isSlim) {\n          t.createdCallback();\n          Slim.asap(function () {\n            Slim.commit(t, tProp);\n            t[tProp] = t[_$2].repeater[tProp];\n          });\n        } else {\n          Slim.commit(t, tProp);\n          t[tProp] = t[_$2].repeater[tProp];\n        }\n      });\n      hook.parentElement.insertBefore(frag, hook);\n    });\n    source[_$2].reversed[tProp] = true;\n  }, true);\n\n  !__flags.isChrome && Slim.customDirective(function (attr) {\n    return (/^s:repeat$/.test(attr.nodeName)\n    );\n  }, function (source, templateNode, attribute) {\n    var path = attribute.nodeValue;\n    var tProp = 'data';\n    if (path.indexOf(' as')) {\n      tProp = path.split(' as ')[1] || tProp;\n      path = path.split(' as ')[0];\n    }\n\n    var repeater = document.createElement('slim-repeat');\n    repeater[_$2].boundParent = source;\n    repeater.dataProp = tProp;\n    repeater.dataPath = attribute.nodeValue;\n    repeater.templateNode = templateNode.cloneNode(true);\n    repeater.templateNode.removeAttribute('s:repeat');\n    templateNode.parentNode.insertBefore(repeater, templateNode);\n    Slim.removeChild(templateNode);\n    Slim.bind(source, repeater, path, function () {\n      var dataSource = Slim.lookup(source, path);\n      repeater.dataSource = dataSource || [];\n    });\n\n    // source._executeBindings()\n  }, true);\n\n  var SlimRepeater = function (_Slim) {\n    _inherits(SlimRepeater, _Slim);\n\n    function SlimRepeater() {\n      _classCallCheck(this, SlimRepeater);\n\n      return _possibleConstructorReturn(this, (SlimRepeater.__proto__ || Object.getPrototypeOf(SlimRepeater)).apply(this, arguments));\n    }\n\n    _createClass(SlimRepeater, [{\n      key: '_bindChildren',\n      value: function _bindChildren(tree) {\n        var _this6 = this;\n\n        tree = Array.prototype.slice.call(tree);\n        var directChildren = Array.prototype.filter.call(tree, function (child) {\n          return child.parentNode.localName === 'slim-root-fragment';\n        });\n        directChildren.forEach(function (child, index) {\n          child.setAttribute('s:iterate', _this6.dataPath + ' : ' + index);\n          Slim.selectRecursive(child).forEach(function (e) {\n            Slim._$(e).repeater[_this6.dataProp] = _this6.dataSource[index];\n            if (e instanceof Slim) {\n              e[_this6.dataProp] = _this6.dataSource[index];\n            }\n          });\n        });\n      }\n    }, {\n      key: 'onRender',\n      value: function onRender() {\n        if (!this.boundParent) return;\n        var tree = Slim.selectRecursive(this);\n        this.boundParent && this.boundParent._bindChildren(tree);\n        this.boundParent._executeBindings();\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this7 = this;\n\n        if (!this.boundParent) return;\n        Slim.qSelectAll(this, '*').forEach(function (e) {\n          Slim.unbind(_this7.boundParent, e);\n        });\n        if (!this.dataSource || !this.templateNode || !this.boundParent) {\n          return _get(SlimRepeater.prototype.__proto__ || Object.getPrototypeOf(SlimRepeater.prototype), 'render', this).call(this, '');\n        }\n        var newTemplate = Array(this.dataSource.length).fill(this.templateNode.outerHTML).join('');\n        this.innerHTML = '';\n        _get(SlimRepeater.prototype.__proto__ || Object.getPrototypeOf(SlimRepeater.prototype), 'render', this).call(this, newTemplate);\n      }\n    }, {\n      key: 'dataSource',\n      get: function get() {\n        return this._dataSource;\n      },\n      set: function set(v) {\n        if (this._dataSource !== v) {\n          this._dataSource = v;\n          this.render();\n        }\n      }\n    }, {\n      key: 'boundParent',\n      get: function get() {\n        return this[_$2].boundParent;\n      }\n    }]);\n\n    return SlimRepeater;\n  }(Slim);\n\n  Slim.tag('slim-repeat', SlimRepeater);\n\n  if (window) {\n    window['Slim'] = Slim;\n  }\n  if (typeof module !== 'undefined') {\n    module.exports.Slim = Slim;\n  }\n})(window, document, HTMLElement);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/janrembold/GitHub/webcomponent-examples/node_modules/slim-js/Slim.js\n// module id = 2\n// module chunks = 0 1","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/janrembold/GitHub/webcomponent-examples/node_modules/node-libs-browser/node_modules/timers-browserify/main.js\n// module id = 3\n// module chunks = 0 1","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/janrembold/GitHub/webcomponent-examples/node_modules/setimmediate/setImmediate.js\n// module id = 4\n// module chunks = 0 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/janrembold/GitHub/webcomponent-examples/node_modules/process/browser.js\n// module id = 5\n// module chunks = 0 1","module.exports = {\r\n    tag: function(selector) {\r\n        return function(target) {\r\n            window.Slim.tag(selector, target);\r\n        };\r\n    },\r\n\r\n    template: function(tpl) {\r\n        return function(target) {\r\n            target.prototype.__defineGetter__('template', function() {\r\n                return tpl;\r\n            });\r\n        }\r\n    },\r\n\r\n    useShadow: function(value) {\r\n        return function(target) {\r\n            target.prototype.__defineGetter__('useShadow', function() { return value; });\r\n        }\r\n    },\r\n\r\n    attribute: function(target, key, descriptor) {\r\n        target.constructor.observedAttributes = target.constructor.observedAttributes || [];\r\n        const attr = window.Slim.camelToDash(key);\r\n        target.constructor.observedAttributes.push(attr);\r\n        Slim._$(target.constructor).autoBoundAttributes.push(key);\r\n        descriptor.configurable = true;\r\n        descriptor.writable = true;\r\n        return descriptor;\r\n    }\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/janrembold/GitHub/webcomponent-examples/node_modules/slim-js/Decorators.js\n// module id = 6\n// module chunks = 0 1"],"sourceRoot":""}